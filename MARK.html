<html><head>
<link rel='stylesheet' href='style.css' type='text/css'>
</head><body>
<h1><span>MARK: deterministic </span><span class='mark strong'>*</span><span class='strong'>Markdown</span><span class='mark strong'>*</span><span> dialect
</span></h1>
<p></p>
<p><span>The MARK is a minimalistic markup format based on </span><span class='mark link'>[</span><span class='link'>Markdown</span><span class='mark link'>][m]</span><span>.
</span><span>Markup languages have a long and boring history; we can 
</span><span>mention </span><span class='mark code'>`</span><span class='code'>man</span><span class='mark code'>`</span><span>, </span><span class='mark code'>`</span><span class='code'>TeX</span><span class='mark code'>`</span><span> or even </span><span class='mark code'>`</span><span class='code'>HTML</span><span class='mark code'>`</span><span> that now requires some 
</span><span>million lines of code to properly parse and display itself.
</span><span>The huge upside of </span><span class='mark code'>`</span><span class='code'>Markdown</span><span class='mark code'>`</span><span> is that it is simple and intuitive.
</span><span>The key downside is ambiguity and incompatibility of parsers.
</span></p>
<p><span>MARK started as a subset of Markdown with a formal grammar,
</span><span>hence zero ambiguity. If two MARK parsers are incompatible,
</span><span>that is a bug in at least one of them. MARK is made to tolerate
</span><span>mishaps to some degree, such as merges of concurrent edits.
</span></p>
<p><span>MARK parsing rules are made to be easily implemented with 
</span><span>regular expressions of any kind.
</span></p>
<p></p>
<h2><span>Principles for the formal grammar
</span></h2>
<p></p>
<p><span>There is a legendary unsolvable computer science problem:
</span><span>should we use spaces or tabs? The logic of MARK is to have 
</span><span>only one way to do something. So, can spaces replace tabs?
</span><span>Yes. Can tabs replace spaces? No. Hence, spaces!
</span></p>
<p><span>That logic also applies to the MARK's way of minimizing 
</span><span>Markdown: there must be one format for headers, one format 
</span><span>for bullet lists, etc. The overlap between markup elements 
</span><span>must absolutely be minimized. For example, using </span><span class='mark code'>`</span><span class='code'>*</span><span class='mark code'>`</span><span> both
</span><span>for emphasis and lists is a no-no.
</span></p>
<p><span>To summarize that,
</span></p>
<p></p>
<ol><li><p><span>Intuitive syntax,
</span></p>
</li><li><p><span>One way only,
</span></p>
</li><li><p><span>No ambiguity.
</span></p>
</li></ol>
<p></p>
<p></p>
<h2><span>The formal grammar
</span></h2>
<p></p>
<p><span>MARK formal grammar consists of two orthogonal parts that can
</span><span>and should be parsed separately: block-level and inline. All
</span><span>block-level formatting goes in the beginning of a line, four
</span><span>characters per one level of nesting - be it 
</span></p>
<p></p>
<ul><li><p><span>numbered lists </span><span class='mark code'>`</span><span class='code'> 1. </span><span class='mark code'>`</span><span>,
</span></p>
</li><li><p><span>bulleted lists </span><span class='mark code'>`</span><span class='code'>  - </span><span class='mark code'>`</span><span>,
</span></p>
</li><li><p><span>block quotes </span><span class='mark code'>`</span><span class='code'> >  </span><span class='mark code'>`</span><span>,
</span></p>
</li><li><p><span>code blocks </span><span class='mark code'>`</span><span class='code'>\`\`\`\`</span><span class='mark code'>`</span><span>,
</span></p>
</li><li><p><span>headers (four levels </span><span class='mark code'>`</span><span class='code'> #  </span><span class='mark code'>`</span><span> </span><span class='mark code'>`</span><span class='code'> ## </span><span class='mark code'>`</span><span> </span><span class='mark code'>`</span><span class='code'>### </span><span class='mark code'>`</span><span> </span><span class='mark code'>`</span><span class='code'>####</span><span class='mark code'>`</span><span>),
</span></p>
</li><li><p><span>hyperlinks </span><span class='mark code'>`</span><span class='code'>[a]:</span><span class='mark code'>`</span><span>,
</span></p>
</li><li><p><span>or suchlike.
</span></p>
</li></ul>
<p></p>
<p><span>Block level elements can allow for arbitrary nesting
</span><span>(lists, block quotes), only allow for inline formatting 
</span><span>inside them (headers) or no formatting at all (code, links).
</span></p>
<p><span>Inline elements are either one-piece or </span><span class='mark strong'>*</span><span class='strong'>bracket-like pairs</span><span class='mark strong'>*</span><span>.
</span><span>Either way, the syntax of the element is defined by a regular 
</span><span>expression. Bracket-matching algorithm is the same for all 
</span><span>bracketed elements, be it emphasis, strong emphasis, inline 
</span><span>code, or hyperlinks.
</span></p>
<p></p>
<h2><span>CommonMark critique
</span></h2>
<p></p>
<p><span class='mark link'>[</span><span class='link'>CommonMark</span><span class='mark link'>][c]</span><span> was a notable effort to standardize Markdown.
</span><span>After 10 years, the spec is still changing and there is no 
</span><span>formal grammar, only a human-language description.
</span><span>As the </span><span class='mark link'>[</span><span class='link'>CommonMark spec</span><span class='mark link'>][c]</span><span> says, 
</span></p>
<p></p>
<blockquote><p><span>la la la
</span></p>
</blockquote>
<p></p>
<p><span>That precedent-based intuitive syntax of Markdown is likely the problem here. 
</span><span>If we implement a Markdown parser with neural nets, that approach might 
</span><span>be OK. Except that another neural net might see things differently.
</span><span>Instead, MARK is based on very clear formal rules that are easy
</span><span>to understand, remember and implement in code.
</span></p>
<p></p>
<a><span> http://commonmark.org
</span><span> fireball
</span></a>
</body></html>
